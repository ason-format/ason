var O=class{constructor(e={}){this.indent=e.indent!==void 0?Math.max(1,e.indent):1,this.delimiter=e.delimiter||",",this.useReferences=e.useReferences!==void 0?e.useReferences:true,this.useDictionary=e.useDictionary!==void 0?e.useDictionary:true,this.structureRefs=new Map,this.objectAliases=new Map,this.valueDictionary=new Map,this.valueFirstOccurrence=new Map,this.refCounter=0,this.aliasCounter=0,this.dictCounter=0;}compress(e){this.structureRefs.clear(),this.objectAliases.clear(),this.valueDictionary.clear(),this.valueFirstOccurrence.clear(),this.refCounter=0,this.aliasCounter=0,this.dictCounter=0,this.useReferences&&(this._autoDetectPatterns(e),this._detectRepeatedObjects(e),this.useDictionary&&this._detectFrequentValues(e));let s="",n=this.structureRefs.size>0||this.objectAliases.size>0;if(n){s+=`$def:
`;for(let[r,l]of this.structureRefs.entries())s+=this._sp(1)+`${l.name}:@${l.keys.join(this.delimiter)}
`;let t=this.objectAliases;this.objectAliases=new Map;for(let[r,l]of t.entries()){let y=JSON.parse(r),o=this._serialize(y,2);s+=this._sp(1)+`${l}:${o}
`;}this.objectAliases=t,s+=`$data:
`;}let i=this._serialize(e,n?1:0);return s+i.replace(/^\n/,"").replace(/\n+$/,"")}_autoDetectPatterns(e,s=[],n=new Map){if(Array.isArray(e)&&this._isUniformObjects(e)&&e.length>0){let{keys:i}=this._getMostCommonKeys(e),t=i.join("|");n.has(t)||n.set(t,{keys:i,count:0}),n.get(t).count++;for(let r of e)for(let l of i)this._autoDetectPatterns(r[l],[...s,l],n);}else if(Array.isArray(e))e.forEach((i,t)=>this._autoDetectPatterns(i,[...s,t],n));else if(e&&typeof e=="object")for(let[i,t]of Object.entries(e))this._autoDetectPatterns(t,[...s,i],n);if(s.length===0)for(let[i,t]of n.entries())t.count>=3&&this.structureRefs.set(i,{name:`$${this.refCounter++}`,keys:t.keys,count:t.count});return n}_detectFrequentValues(e,s=new Map,n=true){if(Array.isArray(e))e.forEach(i=>this._detectFrequentValues(i,s,false));else if(e&&typeof e=="object")for(let i of Object.values(e))typeof i=="string"&&i.length>=5&&s.set(i,(s.get(i)||0)+1),this._detectFrequentValues(i,s,false);if(n&&s.size>0){let i=[];for(let[t,r]of s.entries())if(r>=2){let y=t.length*r,o=t.length+3+2*(r-1),a=y-o;a>0&&i.push({value:t,count:r,savings:a});}i.sort((t,r)=>r.savings-t.savings);for(let{value:t}of i)this.valueDictionary.set(t,`#${this.dictCounter++}`);}}_detectRepeatedObjects(e,s=new Map){if(Array.isArray(e))e.forEach(n=>this._detectRepeatedObjects(n,s));else if(e&&typeof e=="object"){let n=Object.keys(e);if(n.length>0&&n.length<=3&&!n.some(t=>{let r=e[t];return Array.isArray(r)?r.length>0:r&&typeof r=="object"?Object.keys(r).length>0:false})){let t=JSON.stringify(e);s.set(t,(s.get(t)||0)+1);}for(let i of Object.values(e))this._detectRepeatedObjects(i,s);}if(s.size>0&&this.objectAliases.size===0)for(let[n,i]of s.entries())i>=2&&this.objectAliases.set(n,`&obj${this.aliasCounter++}`);}decompress(e){var y;let s=e.split(`
`),n=new Map,i=new Map,t=new Map,r=0;if(((y=s[0])==null?void 0:y.trim())==="$def:"){let o=1;for(;o<s.length&&s[o].trim()!=="$data:";){let a=s[o],c=a.length-a.trimStart().length,d=a.trim(),f=d.indexOf(":");if(f>0){let p=d.slice(0,f).trim(),u=d.slice(f+1).trim();if(u.startsWith("@")){let h=u.slice(1).split(this.delimiter);n.set(p,h),o++;}else if(p.startsWith("#")){let h=u.startsWith('"')?JSON.parse(u):u;t.set(p,h),o++;}else if(p.startsWith("&obj"))if(u===""){o++;let h=[];for(;o<s.length&&s[o].trim()!=="$data:"&&s[o].length-s[o].trimStart().length>c;)h.push(s[o]),o++;let g=this._parseLines(h,0);i.set(p,g);}else {let h=this._parseVal(u);i.set(p,h),o++;}else o++;}else o++;}r=o+1;}return this.structureDefs=n,this.parsedAliases=i,this.parsedValueDict=t,this._parseLines(s,r)}_sp(e){return this.indent===0?"":" ".repeat(this.indent*e)}_serialize(e,s){let n=this._sp(s);if(e==null)return "null";if(typeof e=="boolean")return e?"true":"false";if(typeof e=="number")return String(e);if(typeof e=="string"){let i=this.valueDictionary.get(e);return i&&this.useDictionary?this.valueFirstOccurrence.has(e)?i:(this.valueFirstOccurrence.set(e,true),/[\n\r\t]/.test(e)||e===""||e==="null"||e==="true"||e==="false"||/^-?\d+\.?\d*$/.test(e)||/^[@$&#\-\[]/.test(e)||e==="[]"||e==="{}"?`${JSON.stringify(e)} ${i}`:`${e} ${i}`):/[\n\r\t]/.test(e)||e===""||e==="null"||e==="true"||e==="false"||/^-?\d+\.?\d*$/.test(e)||/^[@$&#\-\[]/.test(e)||e==="[]"||e==="{}"?JSON.stringify(e):e}if(Array.isArray(e)){if(e.length===0)return "[]";if(this._isUniformObjects(e)){let{keys:t}=this._getMostCommonKeys(e),r=t.join("|"),l=this.structureRefs.get(r);if(e.every(a=>t.every(c=>{let d=a[c];return d===null||typeof d!="object"}))&&e.every(c=>Object.keys(c).every(f=>t.includes(f)))){let c=l?`$${l.name}`:`@${t.join(this.delimiter)}`,d=`[${e.length}]${c}
`;for(let f of e){let p=t.map(u=>this._escVal(f[u]));d+=n+p.join(this.delimiter)+`
`;}return d.trimEnd()}let o=`
`;for(let a of e){o+=n+`- 
`;for(let c of Object.keys(a)){let d=a[c],f=this._serialize(d,s+2);f.startsWith(`
`)?o+=this._sp(s+1)+c+":"+f+`
`:o+=this._sp(s+1)+c+":"+f+`
`;}}return o.trimEnd()}if(e.every(t=>t===null||typeof t!="object"))return `[${e.map(r=>this._escVal(r)).join(this.delimiter)}]`;let i=`
`;for(let t of e)i+=n+"- "+this._serialize(t,s+1).trim()+`
`;return i.trimEnd()}if(typeof e=="object"){if(Object.keys(e).length===0)return "{}";let i=JSON.stringify(e),t=this.objectAliases.get(i);if(t)return t;let r=s===0?"":`
`;for(let[l,y]of Object.entries(e)){let o=l,a=y,d=false,f=!l.includes(".");for(;f&&a&&typeof a=="object"&&!Array.isArray(a)&&Object.keys(a).length===1&&!this.objectAliases.has(JSON.stringify(a));){let g=Object.keys(a)[0];if(g.includes("."))break;o+="."+g,a=a[g],d=true;}let u=/[\n\r\t]/.test(o)||!d&&(l.includes(".")||l===".")||o===""||o==="null"||o==="true"||o==="false"||/^[@$&#\-\[]/.test(o)||/^-?\d+\.?\d*$/.test(o)?JSON.stringify(o):o,h=this._serialize(a,s+1);if(h.startsWith(`
`))r+=n+u+":"+h+`
`;else if(h.includes(`
`))r+=n+u+":"+h+`
`;else {let m=/[\n\r\t]/.test(h)?JSON.stringify(h):h;r+=n+u+":"+m+`
`;}}return r.trimEnd()}return String(e)}_escVal(e){if(e===null)return "null";if(typeof e=="boolean")return e?"true":"false";if(typeof e=="number")return String(e);if(typeof e=="string"){let s=this.valueDictionary.get(e);return s&&this.useDictionary?this.valueFirstOccurrence.has(e)?s:(this.valueFirstOccurrence.set(e,true),new RegExp(`[${this.delimiter}\\n\\r\\t]`).test(e)||e===""||e==="null"||e==="true"||e==="false"||/^-?\d+\.?\d*$/.test(e)?`${JSON.stringify(e)} ${s}`:`${e} ${s}`):new RegExp(`[${this.delimiter}\\n\\r\\t"]`).test(e)||e===""||e==="null"||e==="true"||e==="false"||/^-?\d+\.?\d*$/.test(e)?JSON.stringify(e):e}if(typeof e=="object"){let s=this._serialize(e,0).trim();return s.includes(`
`)?JSON.stringify(e):s}return JSON.stringify(e)}_deepMerge(e,s){for(let n in s)s[n]&&typeof s[n]=="object"&&!Array.isArray(s[n])?(e[n]||(e[n]={}),this._deepMerge(e[n],s[n])):e[n]=s[n];}_getMostCommonKeys(e){let s=new Map,n=new Map;for(let r of e){let l=Object.keys(r),y=l.slice().sort().join("|");s.set(y,(s.get(y)||0)+1),n.has(y)||n.set(y,l);}let i="",t=0;for(let[r,l]of s.entries())l>t&&(t=l,i=r);return {keys:n.get(i)||[],uniformity:t/e.length}}_isUniformObjects(e){if(e.length===0||!e.every(i=>i&&typeof i=="object"&&!Array.isArray(i)))return  false;let{uniformity:s}=this._getMostCommonKeys(e);return s>=.6}_parseLines(e,s){let n=s;return this._parseValue(e,n,-1).value}_getIndent(e){if(!e||e.trim()==="")return  -1;let s=e.match(/^(\s*)/);return s?s[1].length:0}_parseValue(e,s,n){if(s>=e.length)return {value:null,nextIdx:s};let i=e[s],t=this._getIndent(i),r=i.trim();return r===""?{value:null,nextIdx:s+1}:r==="-"||r.startsWith("- ")?this._parseList(e,s,n):r.startsWith("@")||r.startsWith("[")&&r.includes("]@")||r.startsWith("$")&&!r.startsWith("$def")&&!r.startsWith("$data")?this._parseUniformArray(e,s,n):r.indexOf(":")>0&&t>n?this._parseObject(e,s,n):{value:this._parseVal(r),nextIdx:s+1}}_parseObject(e,s,n){let i={},t=s;for(;t<e.length;){let r=e[t],l=this._getIndent(r),y=r.trim();if(l<=n)break;if(y===""){t++;continue}let o=y.indexOf(":");if(o<=0){t++;continue}let a=y.slice(0,o).trim(),c=y.slice(o+1).trim(),d=a.startsWith('"')?JSON.parse(a):a;if(d.includes(".")&&!a.startsWith('"')){let f=d.split("."),p=f[0],u;if(c==="")if(t++,t<e.length&&this._getIndent(e[t])>l){let h=this._parseValue(e,t,l);u=h.value,t=h.nextIdx;}else u=null;else u=this._parseVal(c),t++;for(let h=f.length-1;h>=1;h--)u={[f[h]]:u};i[p]&&typeof i[p]=="object"&&!Array.isArray(i[p])?this._deepMerge(i[p],u):i[p]=u;continue}if(c==="")if(t++,t<e.length&&this._getIndent(e[t])>l){let f=this._parseValue(e,t,l);i[d]=f.value,t=f.nextIdx;}else i[d]=null;else if(c.startsWith("@")||c.startsWith("[")&&c.includes("]@")){let f=c;if(c.startsWith("[")){let g=c.indexOf("]");g>0&&(parseInt(c.slice(1,g)),f=c.slice(g+1));}let u=f.slice(1).split(this.delimiter),h=[];for(t++;t<e.length&&this._getIndent(e[t])>l;){let g=this._parseCsv(e[t].trim()),m={};u.forEach((_,b)=>{let j=g[b];j!==void 0&&j!==""&&(m[_]=this._parseVal(j));}),h.push(m),t++;}i[d]=h;}else if(c.startsWith("$")&&c.length>1&&c[1]!=="{"){let f=c.slice(1),p=this.structureDefs.get(f);if(p){let u=[];for(t++;t<e.length&&this._getIndent(e[t])>l;){let h=this._parseCsv(e[t].trim()),g={};p.forEach((m,_)=>{let b=h[_];b!==void 0&&b!==""&&(g[m]=this._parseVal(b));}),u.push(g),t++;}i[d]=u;}else i[d]=this._parseVal(c),t++;}else i[d]=this._parseVal(c),t++;}return {value:i,nextIdx:t}}_parseUniformArray(e,s,n){let i=e[s].trim(),r;if(i.startsWith("[")){let a=i.indexOf("]");a>0&&(parseInt(i.slice(1,a)),i=i.slice(a+1));}if(i.startsWith("@"))r=i.slice(1).split(this.delimiter);else if(i.startsWith("$")){let a=i.slice(1);if(r=this.structureDefs.get(a),!r)return {value:[],nextIdx:s+1}}else return {value:[],nextIdx:s+1};let l=[],y=s+1;this._getIndent(e[s]);for(;y<e.length&&!(this._getIndent(e[y])<=n);){let c=e[y].trim();if(c===""){y++;continue}if(c.startsWith("- ")){let d=c.slice(2).split(/\s+(?=\w+:)/),f={};for(let p of d){let u=p.indexOf(":");if(u>0){let h=p.slice(0,u),g=p.slice(u+1);f[h]=this._parseVal(g);}}l.push(f),y++;}else {let d=this._parseCsv(c),f={};r.forEach((p,u)=>{let h=d[u];h!==void 0&&h!==""&&(f[p]=this._parseVal(h));}),l.push(f),y++;}}return {value:l,nextIdx:y}}_parseList(e,s,n){let i=[],t=s,r=this._getIndent(e[s]);for(;t<e.length;){let l=this._getIndent(e[t]);if(l<=n)break;let y=e[t].trim();if(y!=="-"&&!y.startsWith("- ")||l!==r)break;let o=y.slice(2).trim();if(o==="")if(t++,t<e.length&&this._getIndent(e[t])>l){let a=this._parseValue(e,t,l);i.push(a.value),t=a.nextIdx;}else i.push(null);else {let a=t+1<e.length?this._getIndent(e[t+1]):0;if(a>l){let c={},d=o.indexOf(":");if(d>0){let f=o.slice(0,d).trim(),p=o.slice(d+1).trim();c[f]=this._parseVal(p);}for(t++;t<e.length&&this._getIndent(e[t])>l;){let f=e[t],p=this._getIndent(f),u=f.trim();if(p===a&&u.indexOf(":")>0){let h=u.indexOf(":"),g=u.slice(0,h).trim(),m=u.slice(h+1).trim();if(m==="")if(t++,t<e.length&&this._getIndent(e[t])>p){let _=this._parseValue(e,t,p);c[g]=_.value,t=_.nextIdx;}else c[g]=null;else c[g]=this._parseVal(m),t++;}else break}i.push(c);}else {let c=o.indexOf(":");if(c>0&&!o.startsWith("[")&&!o.startsWith("{")){let d=o.slice(0,c).trim(),f=o.slice(c+1).trim();i.push({[d]:this._parseVal(f)});}else i.push(this._parseVal(o));t++;}}}return {value:i,nextIdx:t}}_parseCsv(e){let s=[],n="",i=false;for(let t=0;t<e.length;t++){let r=e[t];r==='"'&&(t===0||e[t-1]!=="\\")?i&&e[t+1]==='"'?(n+='"',t++):(i=!i,n+=r):r===this.delimiter&&!i?(s.push(n),n=""):n+=r;}return s.push(n),s}_parseVal(e){if(e=e.trim(),e==="null")return null;if(e==="true")return  true;if(e==="false")return  false;if(e==="[]")return [];if(e==="{}")return {};if(e.startsWith("#")&&this.parsedValueDict){let n=this.parsedValueDict.get(e);if(n!==void 0)return n}let s=e.match(/^(.+?)\s+(#\d+)$/);if(s&&this.parsedValueDict){let n=s[1],i=s[2];if(!this.parsedValueDict.has(i)){let t=n.startsWith('"')?JSON.parse(n):n;this.parsedValueDict.set(i,t);}return n.startsWith('"')?JSON.parse(n):n}if(e.startsWith("&obj")&&this.parsedAliases){let n=this.parsedAliases.get(e);if(n!==void 0)return n}if(e.startsWith("[")&&e.endsWith("]")){let n=e.slice(1,-1).trim();return n===""?[]:this._parseCsv(n).map(t=>this._parseVal(t))}if(e.startsWith('"'))try{return JSON.parse(e)}catch{return e}if(/^-?\d+\.?\d*$/.test(e)){let n=parseFloat(e);if(!isNaN(n)&&isFinite(n))return n}return e}},k=class{static estimateTokens(e){return typeof e!="string"&&(e=JSON.stringify(e)),Math.ceil(e.length/4)}static compareFormats(e,s){let n=JSON.stringify(e),i=typeof s=="string"?s:JSON.stringify(s),t=this.estimateTokens(n),r=this.estimateTokens(i);return {original_tokens:t,compressed_tokens:r,reduction_percent:parseFloat((100*(1-r/t)).toFixed(2)),original_size:n.length,compressed_size:i.length}}};/**
 * ASON - Aliased Serialization Object Notation
 *
 * @fileoverview Main compression engine for converting JSON to ASON format.
 * ASON is a token-optimized serialization format designed specifically for LLMs,
 * reducing token usage by 20-60% compared to JSON while maintaining full round-trip fidelity.
 *
 * Key Features:
 * - Automatic pattern detection (no hardcoding required)
 * - Uniform array compression with schema extraction
 * - Object aliasing for repeated structures
 * - Inline-first value dictionary for LLM readability
 * - Path flattening for nested single-property objects
 * - Configurable indentation and delimiters
 *
 * @module SmartCompressor
 * @license MIT
 * @version 1.0.0
 */
/**
 * @fileoverview ASON (Aliased Serialization Object Notation) - Main Entry Point
 *
 * This module exports the main compression engine and token counter utilities
 * for converting JSON to ASON format, a token-optimized serialization format
 * designed for Large Language Models (LLMs).
 *
 * ASON reduces token usage by 20-60% compared to JSON while maintaining
 * perfect round-trip fidelity (lossless compression).
 *
 * @module ason
 * @see {@link SmartCompressor} for compression/decompression
 * @see {@link TokenCounter} for token estimation utilities
 * @license MIT
 * @version 1.0.0
 *
 * @example
 * import { SmartCompressor, TokenCounter } from 'ason';
 *
 * const compressor = new SmartCompressor({ indent: 1, useReferences: true });
 * const data = { users: [{id: 1, name: "Alice"}, {id: 2, name: "Bob"}] };
 *
 * // Compress
 * const ason = compressor.compress(data);
 * // Output: users:[2]@id,name\n1,Alice\n2,Bob
 *
 * // Decompress
 * const original = compressor.decompress(ason);
 *
 * // Compare
 * const stats = TokenCounter.compareFormats(data, ason);
 * console.log(`Reduced tokens by ${stats.reduction_percent}%`);
 */export{O as SmartCompressor,k as TokenCounter};